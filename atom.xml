<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Toy&#39;s Blog</title>
  
  <subtitle>美好的事情终将会发生！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianxiaohu.online/"/>
  <updated>2020-03-05T17:18:19.633Z</updated>
  <id>https://tianxiaohu.online/</id>
  
  <author>
    <name>Toy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>debounce</title>
    <link href="https://tianxiaohu.online/2020/03/05/front-end/debounce-vs-throttle/"/>
    <id>https://tianxiaohu.online/2020/03/05/front-end/debounce-vs-throttle/</id>
    <published>2020-03-05T17:18:19.633Z</published>
    <updated>2020-03-05T17:18:19.633Z</updated>
    
    <content type="html"><![CDATA[<p>记录下个人对防抖函数和节流函数的理解，在高频触发的事件中，较为实用。<br> <a id="more"></a></p><h2 id="debounce-func-wait-0-options"><a href="#debounce-func-wait-0-options" class="headerlink" title="_.debounce (func, [wait=0], [options])"></a>_.debounce (func, [wait=0], [options])</h2><p>创建一个防抖动函数。该函数会在 wait 毫秒后调用 func 方法。该函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。可以提供一个 options 对象决定如何调用 func 方法，options.leading 和 options.trailing 决定延迟前后如何触发。func 会传入最后一次传入的参数给防抖动函数。随后调用的防抖动函数返回是最后一次 func 调用的结果。</p><p>个人理解:</p><ul><li><p>wait = 400, leading = false, trailing = true<br>函数不会立即执行，当事件连续触发或两次触发间隔小于400ms的时候函数不会执行，直到事件停止触发且隔时间大于400ms，函数执行一次。若间隔时间小于400ms时再次触发事件，则函数执行时间重新开始计算。</p></li><li><p>wait = 400, leading = true, trailing = false<br>函数先立即执行一次，当事件连续触发或两次触发间隔小于400ms的时候函数不会执行，只有当事件停止触发且间隔时间大于400ms时，函数才会变成可执行状态（此时并不会自动自动触发），此时再次触发事件，函数会立即执行一次。</p></li><li><p>wait = 400, leading = true, trailing = true<br>如果都设为true的话，其实效果是相当于两个的结合，函数首先会执行一次，</p></li></ul><p>场景1：页面resize时候，显示窗口大小<br>场景2：实时动态搜索框</p><p>换一种方式实现Debounce</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throttle-func-wait-0-options"><a href="#throttle-func-wait-0-options" class="headerlink" title="_.throttle (func, [wait=0], [options])"></a>_.throttle (func, [wait=0], [options])</h2><p>创建一个节流函数，在 wait 秒内最多执行 func 一次的函数。该函数提供一个 cancel 方法取消延迟函数调用以及 flush 方法立即调用。可以提供一个 options 对象决定如何调用 func 方法，options.leading 和 options.trailing 决定 wait 前后如何触发。func 会传入最后一次传入的参数给这个函数。随后调用的函数返回是最后一次 func 调用的结果。</p><p>注意: 如果 leading 和 trailing 都设定为 true。 则 func 允许 trailing 方式调用的条件为: 在 wait 期间多次调用。</p><p>相当于是给的bounce方法指定参数： maxWait、leading=true、trailing=true</p><p>场景1：页面缩放始终保持弹窗居中显示<br>场景2：下拉加载</p><p>换一种简单的方式实现Throttle</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>,</span><br><span class="line">        flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">            timer &amp;&amp; clearTimeout(timer)</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流和防抖区别"><a href="#节流和防抖区别" class="headerlink" title="节流和防抖区别"></a>节流和防抖区别</h2><p>最大的不同，通俗点说就是Debounce的函数可能很久都不会执行一次，但是Throttle的函数则保证了在给定的wait时间内肯定会执行一次，保证了函数的执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下个人对防抖函数和节流函数的理解，在高频触发的事件中，较为实用。&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://tianxiaohu.online/2020/03/05/front-end/hello-world/"/>
    <id>https://tianxiaohu.online/2020/03/05/front-end/hello-world/</id>
    <published>2020-03-05T17:18:19.633Z</published>
    <updated>2020-03-05T17:18:19.633Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br> <a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>node中的path</title>
    <link href="https://tianxiaohu.online/2020/03/05/front-end/path-vs-fs/"/>
    <id>https://tianxiaohu.online/2020/03/05/front-end/path-vs-fs/</id>
    <published>2020-03-05T17:18:19.633Z</published>
    <updated>2020-03-05T17:18:19.633Z</updated>
    
    <content type="html"><![CDATA[<p>path 模块提供了一些工具函数，用于处理文件与目录的路径<br> <a id="more"></a></p><h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><p>path 模块提供了一些工具函数，用于处理文件与目录的路径<br> <!-- more --></p><h2 id="1-path-basename-path-ext"><a href="#1-path-basename-path-ext" class="headerlink" title="1. path.basename(path[, ext])"></a>1. path.basename(path[, ext])</h2><p>path.basename() 方法返回一个 path 的最后一部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">'/aaa/bbb/ccc.html'</span>);</span><br><span class="line">=&gt; ccc.html</span><br></pre></td></tr></table></figure><h2 id="2-path-dirname-path"><a href="#2-path-dirname-path" class="headerlink" title="2. path.dirname(path)"></a>2. path.dirname(path)</h2><p>path.dirname() 方法返回一个 path 的目录名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">'/aaa/bbb/ccc.html'</span>);</span><br><span class="line">=&gt; <span class="regexp">/aaa/</span>bbb</span><br></pre></td></tr></table></figure><h2 id="3-path-extname-path"><a href="#3-path-extname-path" class="headerlink" title="3. path.extname(path)"></a>3. path.extname(path)</h2><p>path.extname() 方法返回 path 的扩展名，即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。 如果 path 的最后一部分没有 . 或 path 的文件名（见 path.basename()）的第一个字符是 .，则返回一个空字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">'/aaa/bbb/ccc.html'</span>);</span><br><span class="line">=&gt; .html</span><br></pre></td></tr></table></figure><h2 id="4-path-join-…paths"><a href="#4-path-join-…paths" class="headerlink" title="4. path.join([…paths])"></a>4. path.join([…paths])</h2><p>path.join() 方法使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">'/a'</span>,<span class="string">'b'</span>);             =&gt; <span class="string">'/a/b'</span></span><br><span class="line">path.join(<span class="string">'/a'</span>,<span class="string">'b'</span>, <span class="string">'..'</span>, <span class="string">'c'</span>)   =&gt; <span class="string">'/a/c'</span></span><br></pre></td></tr></table></figure><h2 id="5-path-relative-from-to"><a href="#5-path-relative-from-to" class="headerlink" title="5. path.relative(from, to)"></a>5. path.relative(from, to)</h2><p>path.relative() 方法返回从 from 到 to 的相对路径，通俗点将就是，从from为起点，to相对于它的路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.relative(<span class="string">'/a/b/c/test'</span>, <span class="string">'/a/b/d/test2'</span>);</span><br><span class="line">=&gt; <span class="string">'../../d/test2'</span></span><br></pre></td></tr></table></figure><h2 id="6-path-resolve-…paths"><a href="#6-path-resolve-…paths" class="headerlink" title="6. path.resolve([…paths])"></a>6. path.resolve([…paths])</h2><p>path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径。给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径后返回。如果处理完全部给定的 path 片段后还未生成一个绝对路径，则当前工作目录会被用上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">'/a/b'</span>, <span class="string">'./test'</span>);             =&gt; <span class="regexp">/a/</span>b/test</span><br><span class="line">path.resolve(<span class="string">'a'</span>, <span class="string">'b/c/'</span>, <span class="string">'../d/test'</span>);     =&gt; <span class="regexp">/home/</span>toy/a/b/d/test</span><br></pre></td></tr></table></figure><h1 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h1><h2 id="1-fs-open-path-flags-mode-callback"><a href="#1-fs-open-path-flags-mode-callback" class="headerlink" title="1. fs.open(path, flags[, mode], callback)"></a>1. fs.open(path, flags[, mode], callback)</h2><p>异步地打开文件,callback有两个参数 err和fd  fd是返回的文件描述符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./a.txt'</span>, <span class="string">'r'</span>, <span class="string">'0666'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fd);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-fs-read-fd-buffer-offset-length-position-callback"><a href="#2-fs-read-fd-buffer-offset-length-position-callback" class="headerlink" title="2. fs.read(fd, buffer, offset, length, position, callback)"></a>2. fs.read(fd, buffer, offset, length, position, callback)</h2><p>从 fd 指定的文件中读取数据。<br>buffer 是数据将被写入到的 buffer。<br>offset 是 buffer 中开始写入的偏移量。<br>length 是一个整数，指定要读取的字节数。<br>position 是一个整数，指定从文件中开始读取的位置。 如果 position 为 null，则数据从当前文件位置开始读取。</p><h2 id="3-fs-readFile-file-options-callback"><a href="#3-fs-readFile-file-options-callback" class="headerlink" title="3. fs.readFile(file[, options], callback)"></a>3. fs.readFile(file[, options], callback)</h2><p>异步的读取一个文件的全部内容,如果字符编码未指定，则返回原始的 buffer。它是对read方法的一个进一步封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./a.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="Demo-读取文件"><a href="#Demo-读取文件" class="headerlink" title="Demo - 读取文件"></a>Demo - 读取文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./a.txt'</span>, <span class="string">'r'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> buf = Buffer.alloc(<span class="number">255</span>);</span><br><span class="line">    fs.read(fd, buf, <span class="number">0</span>, <span class="number">6</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, byteRead, buffer</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(byteRead); <span class="comment">// 实际读取的字节数</span></span><br><span class="line">        <span class="built_in">console</span>.log(buffer.toString());   <span class="comment">// 被读取的缓存区buffer</span></span><br><span class="line">        fs.close(fd, err =&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h2 id="4-fs-write-fd-data-position-encoding-callback"><a href="#4-fs-write-fd-data-position-encoding-callback" class="headerlink" title="4. fs.write(fd, data[, position[, encoding]], callback)"></a>4. fs.write(fd, data[, position[, encoding]], callback)</h2><p>写入 data 到 fd 指定的文件。 如果 data 不是一个 Buffer 实例，则该值将被强制转换为一个字符串。<br>position 指向从文件开始写入数据的位置的偏移量，encoding 是期望的字符串编码。回调有三个参数 (err, written, string)，其中 written 指定传入的字符串被写入多少字节</p><p>在 Linux 上，当文件以追加模式打开时，指定位置的写入是不起作用的。 内核会忽略位置参数，并总是将数据追加到文件的末尾。</p><h2 id="5-fs-writeFile-file-data-options-callback"><a href="#5-fs-writeFile-file-data-options-callback" class="headerlink" title="5. fs.writeFile(file, data[, options], callback)"></a>5. fs.writeFile(file, data[, options], callback)</h2><p>异步地写入数据到文件，如果文件已经存在，则写入的内容会替换原有的内容，没有则创建文件。 data 可以是一个字符串或一个 buffer。如果 data 是一个 buffer，则忽略 encoding 选项。它默认为 ‘utf8’。</p><p>它是对write方法的进一步封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(<span class="string">'./a.txt'</span>, <span class="string">'Hello Node.js'</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'write finshed!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><blockquote><p>fs.write()和fs.writeFile()方法的比较(同read)</p></blockquote><p>与fs.readFile()方法和fs.read()方法的关系类似。fs.writeFile()也是对fs.write()方法的进一步封装，使用fs.readFile()方法省略了创建文件描述符的过程，可以更方便的向文件写入数据。</p><blockquote><p>fs.close() 打开的文件最后需要及时关掉</p></blockquote><p>其实如果不调用close()并不会立即抛出异常，但是Node对同时打开的文件数量是有限制的。如果你不停的open一个文件而不close，最后将会抛出异常：EMFILE: too many open files error.</p><hr><h2 id="6-fs-appendFile-file-data-options-callback"><a href="#6-fs-appendFile-file-data-options-callback" class="headerlink" title="6. fs.appendFile(file, data[, options], callback)"></a>6. fs.appendFile(file, data[, options], callback)</h2><p>异步地追加数据到一个文件，如果文件不存在则创建文件。 data 可以是一个字符串或 buffer。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.appendFile(<span class="string">'./a.txt'</span>, <span class="string">', Hello Hujiang!'</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'append complete!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="Demo-写入内容到文件"><a href="#Demo-写入内容到文件" class="headerlink" title="Demo - 写入内容到文件"></a>Demo - 写入内容到文件</h2><p>注意此时应该用读写模式打开文件，否则写入不成功，会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./a.txt'</span>, <span class="string">'r+'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> buf = Buffer.from(<span class="string">'Nodejs好牛逼'</span>);</span><br><span class="line">    <span class="comment">//只写入“好牛逼”这三个字</span></span><br><span class="line">    fs.write(fd, buf, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, written, buffer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(written); <span class="comment">// 实际读取的字节数</span></span><br><span class="line">        <span class="built_in">console</span>.log(buffer.toString());   <span class="comment">// 被读取的缓存区buffer</span></span><br><span class="line">        fs.close(fd, err =&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>刷新缓存区</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./a.txt'</span>, <span class="string">'r+'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> buf = Buffer.from(<span class="string">'Nodejs好牛逼'</span>);</span><br><span class="line">    <span class="comment">//只写入“好牛逼”这三个字</span></span><br><span class="line">    fs.write(fd, buf, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, written, buffer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(written); <span class="comment">// 实际写入的字节数</span></span><br><span class="line">        fs.write(fd, buf, <span class="number">6</span>, <span class="number">6</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, written, buffer</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(written);</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;path 模块提供了一些工具函数，用于处理文件与目录的路径&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node.js" scheme="https://tianxiaohu.online/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>javascript 定时器是如何工作的</title>
    <link href="https://tianxiaohu.online/2020/03/05/front-end/How-JavaScript-Timer-Work/"/>
    <id>https://tianxiaohu.online/2020/03/05/front-end/How-JavaScript-Timer-Work/</id>
    <published>2020-03-05T17:18:19.633Z</published>
    <updated>2020-03-05T17:18:19.633Z</updated>
    
    <content type="html"><![CDATA[<p>其实说起JavaScript中的定时器(<em>Timer</em>)中的 <em>setTimeout()</em> 方法，从事开发的同学想必都不会陌生，觉得这些东西很简单很基础。但是有时候恰恰是基础简单的东西，才越容易被忽略。先看一段代码：<br> <a id="more"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>如果一眼看出了结果，那稍微改动一下，这样呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处仅代表模拟一个耗时运算，这里假设时间大于1秒，</span></span><br><span class="line"><span class="comment">// 便于理解本文的重点，此处不需要过分探究执行时间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am run'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>不通过Console控制台运行，能第一时间知道打印的结果么？如果有点不确定，骚年，继续往下看吧。这段代码仔细研究下其实还是蛮有（keng）趣（die）的。个人认为，这也是Javascript语言相比其他编程语言不严谨的地方。当然，为了能够更好的驾驭Javascript这门神奇的语言，这些东西是必须掌握的。</p><h2 id="JS代码是怎么执行的"><a href="#JS代码是怎么执行的" class="headerlink" title="JS代码是怎么执行的"></a>JS代码是怎么执行的</h2><p>那首先应该从JS代码执行说起，JS引擎会在内存中分配堆区（heap）和栈区（stack），那么JS又是以怎样的顺序执行的呢？先看一段很简单的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    B(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newNum = num * num;</span><br><span class="line">    <span class="built_in">console</span>.log(newNum);</span><br><span class="line">&#125;</span><br><span class="line">A();</span><br></pre></td></tr></table></figure><p>当代码运行的时候，为便于理解我们假设栈底有一个main()方法（类似于Java中的入口Main方法）作为运行的开始。</p><p>1.代码开始执行</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/797e315861455afca7ba11e13d9cfa1a.png" alt="第1步"></p><p>2.运行A()方法，将A()入栈，此时A上下文中存在变量 a = 3</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/aefcc296c8a4d0b9f0b8fef7ffd59e13.png" alt="第2步"></p><p>3.调用B()方法，将B()入栈，此时B上下文中存在变量 num = 3，newNum = 9</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/ad890e7e9f1ddde217319a4cce456b8a.png" alt="第3步"></p><p>4.调用B()方法中的console.log()，入栈，控制台打印 9</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/69c0a4dcbe95361966a1b3d5aebe3793.png" alt="第4步"></p><p>5.继续运行，依次将console.log()，和B()方法出栈</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/6b6ec3ba7b90eb0ad2b1a514d2a6e4d5.png" alt="第5步"></p><p>6.A()方法运行完毕出栈</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/4ea0f6faf5bfd032ac7915432e614eb8.png" alt="第6步"></p><p>7.代码运行完成，清空栈</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/a68daa08f4a97c0f28ec4e6d4ca0bc7d.png" alt="第7步"></p><p>这就是一段简单的代码在堆栈中的执行情况，看明白了就能开始介绍Javascript引擎的另外一个机制。</p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>众所周知，<strong>Javascript引擎</strong>（以下简称<em>JS引擎</em>）是单线程的，在某一个特定的时间内只能执行一个任务，并阻塞其他任务的执行，也就是说这些任务是串行的。这样的话，用户不得不等待一个耗时的操作完成之后才能进行后面的操作，这显然是不能容忍的，但是实际开发中我们却可以使用异步代码来解决。举个特殊栗子——计算机CPU，我们可以听着音乐的同时愉快的码代码，看起来播放音乐和编辑代码是并行的，其实不然。在计算机中并没有绝对意义上的并行，从微观上来看，单核心的CPU其实在同一个时间片内只能处理单一的任务，一旦某个进程的时间片结束，CPU会马上调度另一个进程执行，先前的进程则处于挂起状态等待获得时间片后继续执行，如此反复，宏观上看起来这些任务就是并行处理的。</p><p>回到我们熟悉的JS引擎，为实现这样的特性，这里就需要引申出一个重要的东西，<em>Event Loop</em>（事件循环）。</p><p>当异步方法比如这里的<strong>setTimeout()</strong>，或者<strong>ajax请求</strong>、<strong>DOM事件执行</strong>的时候，会交由浏览器内核的其他模块去管理。当异步的方法满足触发条件后，该模块就会将方法推入到一个任务队列（<em>task queue</em>）中，当主线程代码执行完毕处于空闲状态的时候，就会去检查任务队列，将队列中第一个任务入栈执行，完毕后继续检查任务队列，如此循环。前提条件是主线程处于空闲状态，这就是事件循环的模型。</p><h2 id="SetTimeout"><a href="#SetTimeout" class="headerlink" title="SetTimeout();"></a>SetTimeout();</h2><p>明白了上面的东西，那理解setTimeout的机制就容易得多了。回到开篇的第一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer1</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer2</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>为了让大家更直观的看到执行的顺序，做了一个GIF</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/15/7213bb28fd30caa871d8ef75f425475a.gif" alt="执行步骤gif"></p><p>图上可以看出，首先依然是main()开始，首先第一个console.log()入栈执行，执行完毕控制台打印’start’后出栈，紧接着执行到setTimeout定时器，此时JS引擎会将定时器交给浏览器的另一个模块去管理（为方便理解这里把它叫做Timer模块），然后主线程继续向下执行，紧接着将第二个定时器也交给Timer模块，然后执行到第二个console.log()，控制台打印’end’，执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer模块会检查其中的异步代码，一旦满足触发条件，就会将它添加到任务队列中。Timer2延迟100ms，所以会早于Timer1被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将Timer2回调中的console.log()执行，控制台打印’world’，然后执行栈空闲后继续检查任务队列，将Timer1的代码压入执行栈中执行，控制台打印’hello’，清空执行栈，此时任务队列为空，执行结束。</p><p>控制台依次打印出：</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/15/cebca6ff2376a956c7068066827c6557.png" alt="控制台打印"></p><p>再来看开篇第二段改版代码，就比较好玩了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer1</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer2</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处仅代表模拟一个耗时运算，这里假设时间大于1秒，</span></span><br><span class="line"><span class="comment">// 便于理解本文的重点，此处不需要过分探究执行时间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer3</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am run'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>和第一段不同的是，在最后一个定时器前加了一段for循环，（注：此处仅用来模拟一段比较耗时的运算，假设时间大于1秒，代码真正执行时间不必深究）。chrome控制台运行结果是：</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/15/ac2f1caa8cf74b0c699567a66dd59e2b.png" alt="控制台打印"></p><p>前面的那张Gif图看懂了以后，其实从’world’之前的打印应该都是没有问题的。但是奇怪的地方就是，Timer3仅仅延迟了100ms，反而在另外两个Timer之后执行了。其实这里原因很简单，因为在Timer1和Timer2加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的Timer1和Timer2并不会得以执行。当for循环结束，这时才将Timer3交由Timer模块去管理，继续执行后续代码打印’end’，清空执行栈。虽然在这里Timer3的延迟时间最短，但是加入任务队列后还是会排在Timer1和Timer2的后面，所以此时按顺序执行任务队列中的代码，依次打印’hello’、’world’、’I am run’。同时需要注意的是，这种情况下的三个定时器延迟执行的时间已经远远超过了指定的时间。</p><p>还有一点值得特别注意的是，有些同学可能会写过这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>其实JS引擎在处理这段代码的时候，并不是真正的延迟0ms执行。不同的浏览器会默认有一个最小的延迟时间，低于这个时间间隔会按照默认最小的时间间隔来处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们发现不论事件循环（_Event Loop_）模型还是setTimeout机制，其实并不是难点，但却是很多开发同学容易忽略的点。很多问题的产生可能就是因为忽略了一些简单的原理导致的。所以这些基本的知识点需要掌握扎实，才能更好的驾驭Javascript。如果有兴趣可以翻墙看一看下面参考中的视频，强烈推荐！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener">Philip Roberts: What the heck is the event loop anyway?</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实说起JavaScript中的定时器(&lt;em&gt;Timer&lt;/em&gt;)中的 &lt;em&gt;setTimeout()&lt;/em&gt; 方法，从事开发的同学想必都不会陌生，觉得这些东西很简单很基础。但是有时候恰恰是基础简单的东西，才越容易被忽略。先看一段代码：&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
</feed>
