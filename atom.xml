<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Toy&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianxiaohu.online/"/>
  <updated>2020-03-19T16:28:41.513Z</updated>
  <id>https://tianxiaohu.online/</id>
  
  <author>
    <name>Toy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS移动端自适应解决方案</title>
    <link href="https://tianxiaohu.online/2020/03/19/front-end/css/css-responsive/"/>
    <id>https://tianxiaohu.online/2020/03/19/front-end/css/css-responsive/</id>
    <published>2020-03-19T16:28:41.513Z</published>
    <updated>2020-03-19T16:28:41.513Z</updated>
    
    <content type="html"><![CDATA[<p>都说前端开发苦逼，一大原因就是成天要面对千变万化的手机屏幕尺寸，解决数不尽的兼容性问题。移动端屏幕CSS自适应就是个非常常见的需求，今天就将平时工作中采用的方案分享出来。</p><a id="more"></a><p>其实前端做CSS自适应的方案有很多，这次仅仅介绍一种在自己工作中比较常用的方案。具体步骤如下：</p><h3 id="1-根节点font-size处理逻辑："><a href="#1-根节点font-size处理逻辑：" class="headerlink" title="1. 根节点font-size处理逻辑："></a>1. 根节点<code>font-size</code>处理逻辑：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">designWidth, maxWidth</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> doc = <span class="built_in">document</span>, win = <span class="built_in">window</span>, docEl = doc.documentElement, tid;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">refreshRem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = docEl.getBoundingClientRect().width;</span><br><span class="line">    maxWidth = maxWidth || <span class="number">540</span>;</span><br><span class="line">    width &gt; maxWidth &amp;&amp; (width = maxWidth);</span><br><span class="line">    <span class="keyword">var</span> rem = (width * <span class="number">100</span>) / designWidth;</span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">'px'</span>;</span><br><span class="line">    <span class="keyword">var</span> actualSize = <span class="built_in">parseFloat</span>(<span class="built_in">window</span>.getComputedStyle(<span class="built_in">document</span>.documentElement)[<span class="string">'font-size'</span>]);</span><br><span class="line">    <span class="keyword">if</span> (actualSize !== rem &amp;&amp; actualSize &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Math</span>.abs(actualSize - rem) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> remScaled = rem * rem / actualSize;</span><br><span class="line">      docEl.style.fontSize = remScaled + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  refreshRem();</span><br><span class="line">  win.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(tid);</span><br><span class="line">    tid = setTimeout(refreshRem, <span class="number">300</span>);</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">  win.addEventListener(<span class="string">'pageshow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">      clearTimeout(tid);</span><br><span class="line">      tid = setTimeout(refreshRem, <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (doc.readyState === <span class="string">'complete'</span>) &#123;</span><br><span class="line">    doc.body.style.fontSize = <span class="string">'16px'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      doc.body.style.fontSize = <span class="string">'16px'</span>;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">750</span>, <span class="number">750</span>);</span><br></pre></td></tr></table></figure><h3 id="2-在页面引入"><a href="#2-在页面引入" class="headerlink" title="2. 在页面引入"></a>2. 在页面引入</h3><p>将上述代码置于html的 <code>&lt;head&gt;</code> 标签中，优先于页面的css代码加载。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"><span class="comment">&lt;!-- 此处放上面的代码 --&gt;</span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 业务css代码放在后面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-编写css代码"><a href="#3-编写css代码" class="headerlink" title="3. 编写css代码"></a>3. 编写css代码</h3><p>配置好后，在css代码中就可以用<code>rem</code>代替<code>px</code>，一般开发中基本都会使用SASS或者LESS，所以可以借助函数来简化我们的开发工作。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义单位处理函数</span><br><span class="line"><span class="keyword">@function</span> p($px) &#123;</span><br><span class="line">    <span class="keyword">@return</span> $px / <span class="number">100</span> * <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 假设设计稿宽度20px</span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">P</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最后编译成</span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0.2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-一劳永逸的方法"><a href="#4-一劳永逸的方法" class="headerlink" title="4. 一劳永逸的方法"></a>4. 一劳永逸的方法</h3><p>其实不难发现，虽然SASS能够减轻我们很多的开发负担，但是每次写<code>p(20)</code>这样的代码还是会浪费很多时间。有没有一劳永逸的方法呢？<br>答案是有的。如果你开发中使用<code>Webpack</code>作为构建工具，那么<code>postcss-plugin-px2rem</code>插件（详见 <a href="https://github.com/pigcan/postcss-plugin-px2rem" target="_blank" rel="noopener" title="插件文档">插件文档</a>)就会是个好的选择。这样你就可以摆脱频繁写css函数的困扰，直接按照设计稿标注的px值来写就好了。</p><p>webpack 可以配置在对应sass文件的loader里面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> autoprefixer <span class="keyword">from</span> <span class="string">'autoprefixer'</span>;</span><br><span class="line"><span class="keyword">import</span> px2rem <span class="keyword">from</span> <span class="string">'postcss-plugin-px2rem'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置项</span></span><br><span class="line"><span class="keyword">const</span> px2remOption = &#123;</span><br><span class="line">  rootValue: <span class="number">100</span>,</span><br><span class="line">  unitPrecision: <span class="number">5</span>,</span><br><span class="line">  minPixelValue: <span class="number">0</span>,</span><br><span class="line">  ignoreIdentifier: <span class="string">'no'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> postcssLoader = &#123;</span><br><span class="line">  loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">  query: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      autoprefixer(),</span><br><span class="line">      px2rem(px2remOption)</span><br><span class="line">    ],</span><br><span class="line">    minimize: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简化版webpack配置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        loader: [<span class="string">'css-loader'</span>, postcssLoader, <span class="string">'sass-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，css的写法感觉又回到了我们熟悉的样子，webpack会帮我编译成我们需要的rem单位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 20px就是设计稿标注的尺寸</span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是工作中用到的移动端适配方案。希望可以帮到你！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都说前端开发苦逼，一大原因就是成天要面对千变万化的手机屏幕尺寸，解决数不尽的兼容性问题。移动端屏幕CSS自适应就是个非常常见的需求，今天就将平时工作中采用的方案分享出来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://tianxiaohu.online/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>debounce</title>
    <link href="https://tianxiaohu.online/2020/03/19/front-end/javascript/debounce-vs-throttle/"/>
    <id>https://tianxiaohu.online/2020/03/19/front-end/javascript/debounce-vs-throttle/</id>
    <published>2020-03-19T16:28:41.513Z</published>
    <updated>2020-03-19T16:28:41.513Z</updated>
    
    <content type="html"><![CDATA[<p>记录下个人对防抖函数和节流函数的理解，在高频触发的事件中，较为实用。<br> <a id="more"></a></p><h2 id="debounce-func-wait-0-options"><a href="#debounce-func-wait-0-options" class="headerlink" title="_.debounce (func, [wait=0], [options])"></a>_.debounce (func, [wait=0], [options])</h2><p>创建一个防抖动函数。该函数会在 wait 毫秒后调用 func 方法。该函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。可以提供一个 options 对象决定如何调用 func 方法，options.leading 和 options.trailing 决定延迟前后如何触发。func 会传入最后一次传入的参数给防抖动函数。随后调用的防抖动函数返回是最后一次 func 调用的结果。</p><p>个人理解:</p><ul><li><p>wait = 400, leading = false, trailing = true<br>函数不会立即执行，当事件连续触发或两次触发间隔小于400ms的时候函数不会执行，直到事件停止触发且隔时间大于400ms，函数执行一次。若间隔时间小于400ms时再次触发事件，则函数执行时间重新开始计算。</p></li><li><p>wait = 400, leading = true, trailing = false<br>函数先立即执行一次，当事件连续触发或两次触发间隔小于400ms的时候函数不会执行，只有当事件停止触发且间隔时间大于400ms时，函数才会变成可执行状态（此时并不会自动自动触发），此时再次触发事件，函数会立即执行一次。</p></li><li><p>wait = 400, leading = true, trailing = true<br>如果都设为true的话，其实效果是相当于两个的结合，函数首先会执行一次，</p></li></ul><p>场景1：页面resize时候，显示窗口大小<br>场景2：实时动态搜索框</p><p>换一种方式实现Debounce</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throttle-func-wait-0-options"><a href="#throttle-func-wait-0-options" class="headerlink" title="_.throttle (func, [wait=0], [options])"></a>_.throttle (func, [wait=0], [options])</h2><p>创建一个节流函数，在 wait 秒内最多执行 func 一次的函数。该函数提供一个 cancel 方法取消延迟函数调用以及 flush 方法立即调用。可以提供一个 options 对象决定如何调用 func 方法，options.leading 和 options.trailing 决定 wait 前后如何触发。func 会传入最后一次传入的参数给这个函数。随后调用的函数返回是最后一次 func 调用的结果。</p><p>注意: 如果 leading 和 trailing 都设定为 true。 则 func 允许 trailing 方式调用的条件为: 在 wait 期间多次调用。</p><p>相当于是给的bounce方法指定参数： maxWait、leading=true、trailing=true</p><p>场景1：页面缩放始终保持弹窗居中显示<br>场景2：下拉加载</p><p>换一种简单的方式实现Throttle</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>,</span><br><span class="line">        flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">            timer &amp;&amp; clearTimeout(timer)</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流和防抖区别"><a href="#节流和防抖区别" class="headerlink" title="节流和防抖区别"></a>节流和防抖区别</h2><p>最大的不同，通俗点说就是Debounce的函数可能很久都不会执行一次，但是Throttle的函数则保证了在给定的wait时间内肯定会执行一次，保证了函数的执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下个人对防抖函数和节流函数的理解，在高频触发的事件中，较为实用。&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>node中的path</title>
    <link href="https://tianxiaohu.online/2020/03/19/front-end/node/path-vs-fs/"/>
    <id>https://tianxiaohu.online/2020/03/19/front-end/node/path-vs-fs/</id>
    <published>2020-03-19T16:28:41.513Z</published>
    <updated>2020-03-19T16:28:41.513Z</updated>
    
    <content type="html"><![CDATA[<p>path 模块提供了一些工具函数，用于处理文件与目录的路径<br> <a id="more"></a></p><h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><p>path 模块提供了一些工具函数，用于处理文件与目录的路径<br> <!-- more --></p><h2 id="1-path-basename-path-ext"><a href="#1-path-basename-path-ext" class="headerlink" title="1. path.basename(path[, ext])"></a>1. path.basename(path[, ext])</h2><p>path.basename() 方法返回一个 path 的最后一部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">'/aaa/bbb/ccc.html'</span>);</span><br><span class="line">=&gt; ccc.html</span><br></pre></td></tr></table></figure><h2 id="2-path-dirname-path"><a href="#2-path-dirname-path" class="headerlink" title="2. path.dirname(path)"></a>2. path.dirname(path)</h2><p>path.dirname() 方法返回一个 path 的目录名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">'/aaa/bbb/ccc.html'</span>);</span><br><span class="line">=&gt; <span class="regexp">/aaa/</span>bbb</span><br></pre></td></tr></table></figure><h2 id="3-path-extname-path"><a href="#3-path-extname-path" class="headerlink" title="3. path.extname(path)"></a>3. path.extname(path)</h2><p>path.extname() 方法返回 path 的扩展名，即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。 如果 path 的最后一部分没有 . 或 path 的文件名（见 path.basename()）的第一个字符是 .，则返回一个空字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">'/aaa/bbb/ccc.html'</span>);</span><br><span class="line">=&gt; .html</span><br></pre></td></tr></table></figure><h2 id="4-path-join-…paths"><a href="#4-path-join-…paths" class="headerlink" title="4. path.join([…paths])"></a>4. path.join([…paths])</h2><p>path.join() 方法使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">'/a'</span>,<span class="string">'b'</span>);             =&gt; <span class="string">'/a/b'</span></span><br><span class="line">path.join(<span class="string">'/a'</span>,<span class="string">'b'</span>, <span class="string">'..'</span>, <span class="string">'c'</span>)   =&gt; <span class="string">'/a/c'</span></span><br></pre></td></tr></table></figure><h2 id="5-path-relative-from-to"><a href="#5-path-relative-from-to" class="headerlink" title="5. path.relative(from, to)"></a>5. path.relative(from, to)</h2><p>path.relative() 方法返回从 from 到 to 的相对路径，通俗点将就是，从from为起点，to相对于它的路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.relative(<span class="string">'/a/b/c/test'</span>, <span class="string">'/a/b/d/test2'</span>);</span><br><span class="line">=&gt; <span class="string">'../../d/test2'</span></span><br></pre></td></tr></table></figure><h2 id="6-path-resolve-…paths"><a href="#6-path-resolve-…paths" class="headerlink" title="6. path.resolve([…paths])"></a>6. path.resolve([…paths])</h2><p>path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径。给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径后返回。如果处理完全部给定的 path 片段后还未生成一个绝对路径，则当前工作目录会被用上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">'/a/b'</span>, <span class="string">'./test'</span>);             =&gt; <span class="regexp">/a/</span>b/test</span><br><span class="line">path.resolve(<span class="string">'a'</span>, <span class="string">'b/c/'</span>, <span class="string">'../d/test'</span>);     =&gt; <span class="regexp">/home/</span>toy/a/b/d/test</span><br></pre></td></tr></table></figure><h1 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h1><h2 id="1-fs-open-path-flags-mode-callback"><a href="#1-fs-open-path-flags-mode-callback" class="headerlink" title="1. fs.open(path, flags[, mode], callback)"></a>1. fs.open(path, flags[, mode], callback)</h2><p>异步地打开文件,callback有两个参数 err和fd  fd是返回的文件描述符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./a.txt'</span>, <span class="string">'r'</span>, <span class="string">'0666'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fd);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-fs-read-fd-buffer-offset-length-position-callback"><a href="#2-fs-read-fd-buffer-offset-length-position-callback" class="headerlink" title="2. fs.read(fd, buffer, offset, length, position, callback)"></a>2. fs.read(fd, buffer, offset, length, position, callback)</h2><p>从 fd 指定的文件中读取数据。<br>buffer 是数据将被写入到的 buffer。<br>offset 是 buffer 中开始写入的偏移量。<br>length 是一个整数，指定要读取的字节数。<br>position 是一个整数，指定从文件中开始读取的位置。 如果 position 为 null，则数据从当前文件位置开始读取。</p><h2 id="3-fs-readFile-file-options-callback"><a href="#3-fs-readFile-file-options-callback" class="headerlink" title="3. fs.readFile(file[, options], callback)"></a>3. fs.readFile(file[, options], callback)</h2><p>异步的读取一个文件的全部内容,如果字符编码未指定，则返回原始的 buffer。它是对read方法的一个进一步封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./a.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="Demo-读取文件"><a href="#Demo-读取文件" class="headerlink" title="Demo - 读取文件"></a>Demo - 读取文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./a.txt'</span>, <span class="string">'r'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> buf = Buffer.alloc(<span class="number">255</span>);</span><br><span class="line">    fs.read(fd, buf, <span class="number">0</span>, <span class="number">6</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, byteRead, buffer</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(byteRead); <span class="comment">// 实际读取的字节数</span></span><br><span class="line">        <span class="built_in">console</span>.log(buffer.toString());   <span class="comment">// 被读取的缓存区buffer</span></span><br><span class="line">        fs.close(fd, err =&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h2 id="4-fs-write-fd-data-position-encoding-callback"><a href="#4-fs-write-fd-data-position-encoding-callback" class="headerlink" title="4. fs.write(fd, data[, position[, encoding]], callback)"></a>4. fs.write(fd, data[, position[, encoding]], callback)</h2><p>写入 data 到 fd 指定的文件。 如果 data 不是一个 Buffer 实例，则该值将被强制转换为一个字符串。<br>position 指向从文件开始写入数据的位置的偏移量，encoding 是期望的字符串编码。回调有三个参数 (err, written, string)，其中 written 指定传入的字符串被写入多少字节</p><p>在 Linux 上，当文件以追加模式打开时，指定位置的写入是不起作用的。 内核会忽略位置参数，并总是将数据追加到文件的末尾。</p><h2 id="5-fs-writeFile-file-data-options-callback"><a href="#5-fs-writeFile-file-data-options-callback" class="headerlink" title="5. fs.writeFile(file, data[, options], callback)"></a>5. fs.writeFile(file, data[, options], callback)</h2><p>异步地写入数据到文件，如果文件已经存在，则写入的内容会替换原有的内容，没有则创建文件。 data 可以是一个字符串或一个 buffer。如果 data 是一个 buffer，则忽略 encoding 选项。它默认为 ‘utf8’。</p><p>它是对write方法的进一步封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(<span class="string">'./a.txt'</span>, <span class="string">'Hello Node.js'</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'write finshed!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><blockquote><p>fs.write()和fs.writeFile()方法的比较(同read)</p></blockquote><p>与fs.readFile()方法和fs.read()方法的关系类似。fs.writeFile()也是对fs.write()方法的进一步封装，使用fs.readFile()方法省略了创建文件描述符的过程，可以更方便的向文件写入数据。</p><blockquote><p>fs.close() 打开的文件最后需要及时关掉</p></blockquote><p>其实如果不调用close()并不会立即抛出异常，但是Node对同时打开的文件数量是有限制的。如果你不停的open一个文件而不close，最后将会抛出异常：EMFILE: too many open files error.</p><hr><h2 id="6-fs-appendFile-file-data-options-callback"><a href="#6-fs-appendFile-file-data-options-callback" class="headerlink" title="6. fs.appendFile(file, data[, options], callback)"></a>6. fs.appendFile(file, data[, options], callback)</h2><p>异步地追加数据到一个文件，如果文件不存在则创建文件。 data 可以是一个字符串或 buffer。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.appendFile(<span class="string">'./a.txt'</span>, <span class="string">', Hello Hujiang!'</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'append complete!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="Demo-写入内容到文件"><a href="#Demo-写入内容到文件" class="headerlink" title="Demo - 写入内容到文件"></a>Demo - 写入内容到文件</h2><p>注意此时应该用读写模式打开文件，否则写入不成功，会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./a.txt'</span>, <span class="string">'r+'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> buf = Buffer.from(<span class="string">'Nodejs好牛逼'</span>);</span><br><span class="line">    <span class="comment">//只写入“好牛逼”这三个字</span></span><br><span class="line">    fs.write(fd, buf, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, written, buffer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(written); <span class="comment">// 实际读取的字节数</span></span><br><span class="line">        <span class="built_in">console</span>.log(buffer.toString());   <span class="comment">// 被读取的缓存区buffer</span></span><br><span class="line">        fs.close(fd, err =&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>刷新缓存区</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./a.txt'</span>, <span class="string">'r+'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> buf = Buffer.from(<span class="string">'Nodejs好牛逼'</span>);</span><br><span class="line">    <span class="comment">//只写入“好牛逼”这三个字</span></span><br><span class="line">    fs.write(fd, buf, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, written, buffer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(written); <span class="comment">// 实际写入的字节数</span></span><br><span class="line">        fs.write(fd, buf, <span class="number">6</span>, <span class="number">6</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, written, buffer</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(written);</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;path 模块提供了一些工具函数，用于处理文件与目录的路径&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node" scheme="https://tianxiaohu.online/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>如何为已经安装好的 Nginx 添加 SSL 模块</title>
    <link href="https://tianxiaohu.online/2020/03/19/server-end/nginx/nginx-add-ssl-module/"/>
    <id>https://tianxiaohu.online/2020/03/19/server-end/nginx/nginx-add-ssl-module/</id>
    <published>2020-03-19T16:28:41.513Z</published>
    <updated>2020-03-19T16:28:41.513Z</updated>
    
    <content type="html"><![CDATA[<p>待完成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;待完成&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="服务端" scheme="https://tianxiaohu.online/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
      <category term="Nginx" scheme="https://tianxiaohu.online/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx + SSL 配置实现 https 访问</title>
    <link href="https://tianxiaohu.online/2020/03/19/server-end/nginx/nginx-https/"/>
    <id>https://tianxiaohu.online/2020/03/19/server-end/nginx/nginx-https/</id>
    <published>2020-03-19T16:28:41.513Z</published>
    <updated>2020-03-19T16:28:41.513Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何通过 Nginx 来配置 SSL，开启接口的 https 调用。如果你正在开发微信小程序，那么可能会帮得上忙。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>楼主前阵子写小程序，接口在 Http 环境测试通过，二级域名解析完毕，IP映射完毕，心想万事大吉，发布上线。谁料忘记了小程序生产环境接口必须使用 Https 协议。百密一疏… 看来只能干干运维的活儿了。虽然最后搞定了，不过还是踩了些坑的，记录下。</p><p>所以今天要实现功能就是通过我的二级域名 <code>https://api.tianxiaohu.online</code> 来访问服务器接口。</p><h3 id="你需要准备："><a href="#你需要准备：" class="headerlink" title="你需要准备："></a>你需要准备：</h3><p>这部分不是主要的，所以需要你自行搞定，</p><blockquote><p>· 域名（楼主域名阿里云买的）<br>· 将域名解析到主机IP<br>· 服务器安装好 Nginx 环境（安装时务必安装ssl模块 –with-http_ssl_module，很简单，不会的自行Google）</p></blockquote><h3 id="为你的域名申请-SSL-证书"><a href="#为你的域名申请-SSL-证书" class="headerlink" title="为你的域名申请 SSL 证书"></a>为你的域名申请 SSL 证书</h3><p>为域名申请 SSL 证书其实并不复杂。总所周知，大部分的证书提供商是需要收费的，便宜的也得千把块一年。对于普通个人开发者而言确实是一笔不小的开支。当然了，免费的证书也不是没有，无非就是安全性和稳定性不如收费的。其实平时个人使用还是完全可以 cover 的。<br>如果你使用的是阿里云，那么在阿里云上就有免费的证书可以<a href="https://common-buy.aliyun.com/?spm=5176.2020520163.c1583915649459.d1583915649459_0.d94056a7EtHbw3.d94056a7EtHbw3&commodityCode=cas#/buy" target="_blank" rel="noopener">购买</a>。购买完，按照阿里云的使用文档，为自己的域名申请证书就ok了，不赘述~</p><h3 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h3><p>因为之前你已经域名解析到了你的主机IP，接下来我们需要 Nginx 帮我做的事情就是监听服务器的443端口，然后转发到主机的接口服务上。从而实现通过https访问接口。Nginx具体的安装配置也不过多描述，按照文档来就好，相信不会难倒大家，这里只说一个比较棘手的情况，就是此前已经安装好了Nginx，但是并没有附带安装SSL包。</p><p>这种情况是有办法解决的，可以在不卸载 Nginx 的情况下完成SSL包的配置。详细请看<a href="">《如何为已经安装好的 Nginx 添加 SSL 模块》</a></p><p>开始前先说明下楼主的环境情况（不同环境可能操作有差异）：</p><blockquote><p>· 服务器：CentOS 7.x<br>· 本地机器：MacBook Pro<br>· Nginx 版本：1.12.0<br>· Nginx 安装目录：/usr/local/nginx</p></blockquote><h4 id="1-下载-SSL-证书，存放到服务器"><a href="#1-下载-SSL-证书，存放到服务器" class="headerlink" title="1. 下载 SSL 证书，存放到服务器"></a>1. 下载 SSL 证书，存放到服务器</h4><p>如果你的域名 https 已经开通，那么在对应的平台（我的是阿里云）去下载证书文件。在下载的时候要注意选择对应的服务器类型。有 Tomcat、Apache、IIS、Nginx等，本文主要讲解Nginx，所以选择下载Nginx对应的证书文件到你本地。</p><p>下载后你会得到两个证书文件，假设为 <code>cert.pem</code> 和 <code>cert.key</code>。楼主存放到本地 <code>/Users/Toy/ssl</code> 目录。</p><h4 id="2-将证书文件推送到服务器"><a href="#2-将证书文件推送到服务器" class="headerlink" title="2. 将证书文件推送到服务器"></a>2. 将证书文件推送到服务器</h4><p>下载好的证书需要放置到服务器上，可以自己找个目录存放。楼主这里放到Nginx的安装目录里 <code>/usr/local/nginx/cert/ssl</code>。</p><p>创建证书存放目录（目录可自选）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx</span><br><span class="line">mkdir cert</span><br><span class="line">cd cert&#x2F;</span><br><span class="line">mkdir ssl</span><br></pre></td></tr></table></figure><p>推送本地证书文件至服务器新创建的目录：</p><p>推送方法比较多，可以选择使用FTP直接上传，不过需要先在服务器上配置好FTP。楼主比较喜欢简单的 SCP 命令，就是secure copy，是用来进行远程文件拷贝的。数据传输使用 ssh，并且和ssh 使用相同的认证方式，提供相同的安全保证。 </p><p>命令格式：</p><blockquote><p>scp [参数] &lt;源地址（用户名@IP地址或主机名）&gt;:&lt;文件路径&gt; &lt;目的地址（用户名 @IP 地址或主机名）&gt;:&lt;文件路径&gt; </p></blockquote><p>找到之前本地存放证书的目录 <code>/Users/Toy/ssl</code>，然后在终端执行脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;Users&#x2F;Toy&#x2F;ssl&#x2F;cert.pem root@123.123.123.123:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;cert&#x2F;ssl&#x2F;cert.pem</span><br><span class="line">scp &#x2F;Users&#x2F;Toy&#x2F;ssl&#x2F;cert.key root@123.123.123.123:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;cert&#x2F;ssl&#x2F;cert.key</span><br></pre></td></tr></table></figure><p>以上两条命令即可搞定。</p><h4 id="2-开放-443、80-端口"><a href="#2-开放-443、80-端口" class="headerlink" title="2. 开放 443、80 端口"></a>2. 开放 443、80 端口</h4><p>开放端口方法也很多，如果图省事，可以直接在阿里云控制台的安全组里面开放443端口或者80端口。（此方法开启后记得重启服务器，楼主开始也是通过此方法开启，然后一直不生效，坑了我2个小时😓）</p><p>当然也可以通过命令行的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启动防火墙</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line">&#x2F;&#x2F; 开启端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;443&#x2F;tcp --permanent</span><br><span class="line">&#x2F;&#x2F; 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h4 id="3-编辑-nginx-conf-文件，配置-SSL-规则"><a href="#3-编辑-nginx-conf-文件，配置-SSL-规则" class="headerlink" title="3. 编辑 nginx.conf 文件，配置 SSL 规则"></a>3. 编辑 nginx.conf 文件，配置 SSL 规则</h4><p>编辑 nginx.conf</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>配置转发规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 同时监听443和80端口</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    listen       <span class="number">443</span> ssl;</span><br><span class="line">    server_name  api.tianxiaohu.online;</span><br><span class="line">    # 证书目录</span><br><span class="line">    ssl_certificate      /usr/local/nginx/cert/ssl/cert.pem;</span><br><span class="line">    ssl_certificate_key  /usr/local/nginx/cert/ssl/cert.key;</span><br><span class="line">    ssl_session_cache    shared:SSL:<span class="number">1</span>m;</span><br><span class="line">    ssl_session_timeout  <span class="number">5</span>m;</span><br><span class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers  on;</span><br><span class="line">    # 转发规则</span><br><span class="line">    location / &#123;</span><br><span class="line">        # 服务器接口地址</span><br><span class="line">        proxy_pass http:<span class="comment">//127.0.0.1:8080; </span></span><br><span class="line">        add_header Access-Control-Allow-Origin *;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 Nginx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>如此，如果操作不出意外，那么你就可以开心的使用 https 访问接口了。要不要点个右下角赏一杯咖啡？😃</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何通过 Nginx 来配置 SSL，开启接口的 https 调用。如果你正在开发微信小程序，那么可能会帮得上忙。&lt;/p&gt;
    
    </summary>
    
    
      <category term="服务端" scheme="https://tianxiaohu.online/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
      <category term="Nginx" scheme="https://tianxiaohu.online/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>javascript 定时器是如何工作的</title>
    <link href="https://tianxiaohu.online/2020/03/19/front-end/javascript/How-JavaScript-Timer-Work/"/>
    <id>https://tianxiaohu.online/2020/03/19/front-end/javascript/How-JavaScript-Timer-Work/</id>
    <published>2020-03-19T16:28:41.513Z</published>
    <updated>2020-03-19T16:28:41.513Z</updated>
    
    <content type="html"><![CDATA[<p>其实说起JavaScript中的定时器(<em>Timer</em>)中的 <em>setTimeout()</em> 方法，从事开发的同学想必都不会陌生，觉得这些东西很简单很基础。但是有时候恰恰是基础简单的东西，才越容易被忽略。先看一段代码：<br> <a id="more"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>如果一眼看出了结果，那稍微改动一下，这样呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处仅代表模拟一个耗时运算，这里假设时间大于1秒，</span></span><br><span class="line"><span class="comment">// 便于理解本文的重点，此处不需要过分探究执行时间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am run'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>不通过Console控制台运行，能第一时间知道打印的结果么？如果有点不确定，骚年，继续往下看吧。这段代码仔细研究下其实还是蛮有（keng）趣（die）的。个人认为，这也是Javascript语言相比其他编程语言不严谨的地方。当然，为了能够更好的驾驭Javascript这门神奇的语言，这些东西是必须掌握的。</p><h2 id="JS代码是怎么执行的"><a href="#JS代码是怎么执行的" class="headerlink" title="JS代码是怎么执行的"></a>JS代码是怎么执行的</h2><p>那首先应该从JS代码执行说起，JS引擎会在内存中分配堆区（heap）和栈区（stack），那么JS又是以怎样的顺序执行的呢？先看一段很简单的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    B(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newNum = num * num;</span><br><span class="line">    <span class="built_in">console</span>.log(newNum);</span><br><span class="line">&#125;</span><br><span class="line">A();</span><br></pre></td></tr></table></figure><p>当代码运行的时候，为便于理解我们假设栈底有一个main()方法（类似于Java中的入口Main方法）作为运行的开始。</p><p>1.代码开始执行</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/797e315861455afca7ba11e13d9cfa1a.png" alt="第1步"></p><p>2.运行A()方法，将A()入栈，此时A上下文中存在变量 a = 3</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/aefcc296c8a4d0b9f0b8fef7ffd59e13.png" alt="第2步"></p><p>3.调用B()方法，将B()入栈，此时B上下文中存在变量 num = 3，newNum = 9</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/ad890e7e9f1ddde217319a4cce456b8a.png" alt="第3步"></p><p>4.调用B()方法中的console.log()，入栈，控制台打印 9</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/69c0a4dcbe95361966a1b3d5aebe3793.png" alt="第4步"></p><p>5.继续运行，依次将console.log()，和B()方法出栈</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/6b6ec3ba7b90eb0ad2b1a514d2a6e4d5.png" alt="第5步"></p><p>6.A()方法运行完毕出栈</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/4ea0f6faf5bfd032ac7915432e614eb8.png" alt="第6步"></p><p>7.代码运行完成，清空栈</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/a68daa08f4a97c0f28ec4e6d4ca0bc7d.png" alt="第7步"></p><p>这就是一段简单的代码在堆栈中的执行情况，看明白了就能开始介绍Javascript引擎的另外一个机制。</p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>众所周知，<strong>Javascript引擎</strong>（以下简称<em>JS引擎</em>）是单线程的，在某一个特定的时间内只能执行一个任务，并阻塞其他任务的执行，也就是说这些任务是串行的。这样的话，用户不得不等待一个耗时的操作完成之后才能进行后面的操作，这显然是不能容忍的，但是实际开发中我们却可以使用异步代码来解决。举个特殊栗子——计算机CPU，我们可以听着音乐的同时愉快的码代码，看起来播放音乐和编辑代码是并行的，其实不然。在计算机中并没有绝对意义上的并行，从微观上来看，单核心的CPU其实在同一个时间片内只能处理单一的任务，一旦某个进程的时间片结束，CPU会马上调度另一个进程执行，先前的进程则处于挂起状态等待获得时间片后继续执行，如此反复，宏观上看起来这些任务就是并行处理的。</p><p>回到我们熟悉的JS引擎，为实现这样的特性，这里就需要引申出一个重要的东西，<em>Event Loop</em>（事件循环）。</p><p>当异步方法比如这里的<strong>setTimeout()</strong>，或者<strong>ajax请求</strong>、<strong>DOM事件执行</strong>的时候，会交由浏览器内核的其他模块去管理。当异步的方法满足触发条件后，该模块就会将方法推入到一个任务队列（<em>task queue</em>）中，当主线程代码执行完毕处于空闲状态的时候，就会去检查任务队列，将队列中第一个任务入栈执行，完毕后继续检查任务队列，如此循环。前提条件是主线程处于空闲状态，这就是事件循环的模型。</p><h2 id="SetTimeout"><a href="#SetTimeout" class="headerlink" title="SetTimeout();"></a>SetTimeout();</h2><p>明白了上面的东西，那理解setTimeout的机制就容易得多了。回到开篇的第一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer1</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer2</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>为了让大家更直观的看到执行的顺序，做了一个GIF</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/15/7213bb28fd30caa871d8ef75f425475a.gif" alt="执行步骤gif"></p><p>图上可以看出，首先依然是main()开始，首先第一个console.log()入栈执行，执行完毕控制台打印’start’后出栈，紧接着执行到setTimeout定时器，此时JS引擎会将定时器交给浏览器的另一个模块去管理（为方便理解这里把它叫做Timer模块），然后主线程继续向下执行，紧接着将第二个定时器也交给Timer模块，然后执行到第二个console.log()，控制台打印’end’，执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer模块会检查其中的异步代码，一旦满足触发条件，就会将它添加到任务队列中。Timer2延迟100ms，所以会早于Timer1被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将Timer2回调中的console.log()执行，控制台打印’world’，然后执行栈空闲后继续检查任务队列，将Timer1的代码压入执行栈中执行，控制台打印’hello’，清空执行栈，此时任务队列为空，执行结束。</p><p>控制台依次打印出：</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/15/cebca6ff2376a956c7068066827c6557.png" alt="控制台打印"></p><p>再来看开篇第二段改版代码，就比较好玩了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer1</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer2</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处仅代表模拟一个耗时运算，这里假设时间大于1秒，</span></span><br><span class="line"><span class="comment">// 便于理解本文的重点，此处不需要过分探究执行时间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer3</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am run'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>和第一段不同的是，在最后一个定时器前加了一段for循环，（注：此处仅用来模拟一段比较耗时的运算，假设时间大于1秒，代码真正执行时间不必深究）。chrome控制台运行结果是：</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/15/ac2f1caa8cf74b0c699567a66dd59e2b.png" alt="控制台打印"></p><p>前面的那张Gif图看懂了以后，其实从’world’之前的打印应该都是没有问题的。但是奇怪的地方就是，Timer3仅仅延迟了100ms，反而在另外两个Timer之后执行了。其实这里原因很简单，因为在Timer1和Timer2加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的Timer1和Timer2并不会得以执行。当for循环结束，这时才将Timer3交由Timer模块去管理，继续执行后续代码打印’end’，清空执行栈。虽然在这里Timer3的延迟时间最短，但是加入任务队列后还是会排在Timer1和Timer2的后面，所以此时按顺序执行任务队列中的代码，依次打印’hello’、’world’、’I am run’。同时需要注意的是，这种情况下的三个定时器延迟执行的时间已经远远超过了指定的时间。</p><p>还有一点值得特别注意的是，有些同学可能会写过这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>其实JS引擎在处理这段代码的时候，并不是真正的延迟0ms执行。不同的浏览器会默认有一个最小的延迟时间，低于这个时间间隔会按照默认最小的时间间隔来处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们发现不论事件循环（_Event Loop_）模型还是setTimeout机制，其实并不是难点，但却是很多开发同学容易忽略的点。很多问题的产生可能就是因为忽略了一些简单的原理导致的。所以这些基本的知识点需要掌握扎实，才能更好的驾驭Javascript。如果有兴趣可以翻墙看一看下面参考中的视频，强烈推荐！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener">Philip Roberts: What the heck is the event loop anyway?</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实说起JavaScript中的定时器(&lt;em&gt;Timer&lt;/em&gt;)中的 &lt;em&gt;setTimeout()&lt;/em&gt; 方法，从事开发的同学想必都不会陌生，觉得这些东西很简单很基础。但是有时候恰恰是基础简单的东西，才越容易被忽略。先看一段代码：&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
</feed>
